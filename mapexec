#!/usr/bin/env sh
# Open stdin in $EDITOR and execute commands against all, modified, unmodified or wiped lines synchronously or asynchronously. Basically 'batch' but better.
# TODO: Try not to abort when line count changed and find where elements were deleted with diff/git diff or something else. Present a confirmation to the user in case the guess is wrong.

printhelp() {
    printf "%s\n" \
        "mapexec [OPTION...] [COMMAND...] -- [COMMAND...]" \
        "   -A CHARS, --async CHARS" \
        "       Toggle asynchronous command execution for given cases. CHARS can include [amuw]. Toggling will be done for every occurence of [amuw]." \
        "   -a, --all" \
        "       Toggle recording positional arguments as commands to run against all elements." \
        "   --no-all" \
        "       Stop recording positional arguments as commands to run against all elements." \
        "   -m, --modified" \
        "       Toggle recording positional arguments as commands to run against modified elements." \
        "   --no-modified" \
        "       Stop recording positional arguments as commands to run against modified elements." \
        "   -u, --unmodified" \
        "       Toggle reording positional arguments as commands to run against unmodified elements." \
        "   --no-unmodified" \
        "       Stop reording positional arguments as commands to run against unmodified elements." \
        "   -w, --wiped" \
        "       Toggle recording positional arguments as commands to run against unmodified elements." \
        "   --no-wiped" \
        "       Stop recording positional arguments as commands to run against unmodified elements." \
        "   -q, --quote" \
        "      Automatically add quotes in the command." \
        "   --no-quote" \
        "      Revert -q." \
        "   -h, --help" \
        "       Print help message."
}

printusage() {
    printf "Option [%s] is not valid.\n\n" "$1"
    printhelp
}

assertarg() {
    [ -z "$3" ] && {
        printf "Expected %s argument to %s, aborting.\n" "$2" "$1"
        exit 1
    }
}

logargerrq() {
    printf "Invalid argument (%s) given to option [%s]\n" "$2" "$1"
    exit 1
}

registercmd() {
    cmd="$1"

    [ "$autoquote" = "1" ] && quote=\'

    [ "$(( (cmdpos & CMD_MODIFIED) == CMD_MODIFIED ))" -eq 1 ] && modifcmd="$modifcmd $quote$cmd$quote"
    [ "$(( (cmdpos & CMD_UNMODIFIED) == CMD_UNMODIFIED ))" -eq 1 ] && unmodifcmd="$unmodifcmd $quote$cmd$quote"
    [ "$(( (cmdpos & CMD_WIPED) == CMD_WIPED ))" -eq 1 ] && wipecmd="$wipecmd $quote$cmd$quote"
    [ "$(( (cmdpos & CMD_ALL) == CMD_ALL ))" -eq 1 ] && allcmd="$allcmd $quote$cmd$quote"
}

flipcmd() {
    CMD_METHOD="$1"
    methodcmd="$2"
    if [ "$(( (cmdpos & CMD_METHOD) == CMD_METHOD ))" -ne 1 ]
    then
        cmdpos="$(( cmdpos | CMD_METHOD ))"
        if [ "$(( (cmdinit & CMD_METHOD) == CMD_METHOD ))" -ne 1 ]
        then
            eval "$methodcmd="
            cmdinit="$(( cmdinit | CMD_METHOD ))"
        fi
    else
        cmdpos="$(( cmdpos & ~CMD_METHOD ))"
    fi
}

flipasync() {
    chars="$1"
    while [ -n "$chars" ]
    do
        c="${chars%"${chars#?}"}"
        while read -r i <&3 && read -r j <&4
        do
            [ "$c" = "$i" ] && {
                if [ -n "$( eval "printf '%s' \"\$$j\"" )" ]
                then
                    unset "$j"
                else
                    eval "$j='&'"
                fi
            }
            
        done 3<<EOF3 4<<EOF4
a
m
u
w
EOF3
allasync
modifasync
unmodifasync
wipeasync
EOF4
        chars="${chars#?}"
    done
}

parseargs() {
    while [ -n "$1" ]
    do
        if [ "${1%"${1#?}"}" = "-" ]
        then
            if ! [ "${1%"${1#??}"}" = "--" ]
            then
                sopt="${1#?}"

                while [ -n "$sopt" ]
                do
                    opt="$( printf "%s" "$sopt" | cut -c1 )"

                    case "$opt"
                    in
                        A) shift; parseargs --async "$1";;
                        a) parseargs --all;;
                        m) parseargs --modified;;
                        u) parseargs --unmodified;;
                        w) parseargs --wiped;;
                        q) parseargs --quote;;
                        h) parseargs --help;;
                        *) printusage "-$opt"; exit 0;;
                    esac

                    sopt="${sopt#?}"
                done
            else
                opt="${1#??}"
                
                case "$opt"
                in
                    async         ) shift; [ -n "$( printf "%s" "$1" | tr -d 'amuw' )" ] && logargerrq "--async" "$1"; flipasync "$1";;
                    all           ) flipcmd "$CMD_ALL" "allcmd";;
                    modified      ) flipcmd "$CMD_MODIFIED" "modifcmd";;
                    unmodified    ) flipcmd "$CMD_UNMODIFIED" "unmodifcmd";;
                    wiped         ) flipcmd "$CMD_WIPED" "wipecmd";;
                    no-all        ) cmdpos="$(( cmdpos & ~CMD_ALL ))";;
                    no-modified   ) cmdpos="$(( cmdpos & ~CMD_MODIFIED ))";;
                    no-unmodified ) cmdpos="$(( cmdpos & ~CMD_UNMODIFIED ))";;
                    no-wiped      ) cmdpos="$(( cmdpos & ~CMD_WIPED ))";;
                    quote         ) shift; autoquote="1";;
                    no-quote      ) shift; autoquote="0";;
                    help          ) printhelp; exit 0;;
                    ""            ) shift; break;;
                    *             ) printusage "--$opt"; exit 0;;
                esac
            fi
        else
            registercmd "$1"
        fi

        shift
    done

    for i
    do
        registercmd "$i"
    done
}

setdefargs() {
    cmdpos=0
    cmdinit=0
    CMD_MODIFIED=1
    CMD_UNMODIFIED=2
    CMD_WIPED=4
    CMD_ALL=8
    unmodifcmd=:
    modifcmd=:
    wipecmd=:
    allcmd=:
}

validateargs() {
    ( [ -z "$unmodifcmd" ] || [ "$unmodifcmd" = ":" ] ) && ( [ -z "$modifcmd" ] || [ "$modifcmd" = ":" ] ) && ( [ -z "$wipecmd" ] || [ "$wipecmd" = ":" ] ) && ( [ -z "$allcmd" ] || [ "$allcmd" = ":" ] ) && logq "Nothing to do"
}

processargs() {
    [ -z "$unmodifcmd" ] && unmodifcmd=:
    [ -z "$modifcmd" ] && modifcmd=:
    [ -z "$wipecmd" ] && wipecmd=:
    [ -z "$allcmd" ] && allcmd=:
}

logq() {
    printf "%s, exiting.\n" "$@"
    exit 0
}

logerrq() {
    printf "[ERROR]: %s, aborting.\n" "$@" >&2
    exit 1
}

clean() {
    rm -f "$ogtmpfl" "$tmpfl" 2> /dev/null
}

main() {
    ogtmpfl="$( mktemp )"
    tmpfl="$( mktemp )"

    if [ ! -t 0 ]
    then
        cp -f /dev/stdin "$ogtmpfl"
        [ ! -s "$ogtmpfl" ] && logerrq "stdin is empty"
    else
        find . -mindepth 1 -maxdepth 1 -printf "%P\n" -type f -or -type l | sort -dV | sed '/^\./d' > "$ogtmpfl"
    fi

    cp -f "$ogtmpfl" "$tmpfl"

    eval "'$EDITOR' -- '$tmpfl' < /dev/tty"

    [ ! -s "$tmpfl" ] && logerrq "File is wiped"

    lc="$( wc -l < "$ogtmpfl" )"
    [ "$lc" -ne "$( wc -l < "$tmpfl" )" ] && logerrq "Line count changed"

    while read -r i <&3 && read -r f <&4
    do
        if [ "$i" = "$f" ]
        then
            eval "( $unmodifcmd ) $unmodifasync"
        elif [ -z "$f" ]
        then
            eval "( $wipecmd ) $wipeasync"
        else
            eval "( $modifcmd ) $modifasync"
        fi
        eval "( $allcmd ) $allasync"
    done 3< "$ogtmpfl" 4< "$tmpfl"
}

setdefargs
parseargs "$@"
validateargs
processargs
trap clean INT TERM EXIT
main
