#!/usr/bin/env sh
# ffmpeg wrapper for actions I commonly use.
# TODO: Add cut and compress subcommands.

subcommands="concat help"

printhelp() {
    case "$1"
    in
        concat)
            printf "%s\n" \
                "  concat [INFILEs...] [OUTFILE]" \
                "    -F COMMAND, --filter COMMAND" \
                "        Pass filenames through COMMAND before processing. If -s is not passed, the filenames will be passed in a file." \
                "    -f, --force" \
                "        Overwrite the output file if it exists." \
                "    -h, --help" \
                "        Print help message." \
                "    -i, --interactive" \
                "        Prompt before overwriting the output file if it exists." \
                "    -M, --move-to-first" \
                "        Move OUTFILE to the first INFILE after concatenation is finished. First INFILE is computed after option -F is processed. This overrides -m if present." \
                "    -m MOVEFILE, --move-to MOVEFILE" \
                "        Move OUTFILE to MOVEFILE after concatenation is finished. This is overridden by -M if present." \
                "    -n, --no-clobber" \
                "        Do nothing if the output file exists." \
                "    -r, --remove" \
                "        Remove INFILEs if concatenation succeeded." \
                "    -s, --stdin" \
                "        Instead of passing filenames in a file, pass them from stdin to the filter command. This has no effect if -F is not passed."
            ;;
        help)
            printf "%s\n" \
                "  help" \
                "    All options are ignored."
            ;;
        *)
            printf "%s\n" \
                "ffmw SUBCOMMAND [OPTIONs...] [FILEs...] -- [FILEs...]" \
                "" \
                "Global options:" \
                "    -h, --help" \
                "        Print help message." \
                "    -l, --loud" \
                "        Reverse a single -q option." \
                "    -p, --print-performance" \
                "        Print performance statistics after ffmpeg finishes." \
                "    --no-print-performance" \
                "        Revert -p." \
                "    -q, --quiet" \
                "        Suppress stdout. Pass twice to also suppress stderr. This option takes effect only after arguments are parsed." \

            printf "\nValid subcommands: %s\n\n" "$subcommands"
            lastsubcmd="$( printf "%s" "$subcommands" | sed 's/.*\s//' )"
            for i in $subcommands
            do
                printhelp "$i"
                [ "$i" = "$lastsubcmd" ] || printf "\n"
            done
            ;;
    esac
}

printusage() {
    printf "Option [%s] is not valid.\n\n" "$1" >&2
    printhelp "$2"
    exit 1
}

printferr() {
    # shellcheck disable=SC2059
    >&2 printf "$@"
}

assertarg() {
    [ -z "$3" ] && {
        printferr "Expected %s argument to %s, exiting.\n" "$2" "$1"
        exit 1
    }
}

assertcmd() {
    if [ -n "$1" ]
    then
        iscmdvalid="0"
        for i in $subcommands
        do
            [ "$i" = "$1" ] && iscmdvalid="1"
        done
        [ "$iscmdvalid" = "1" ] || {
            printferr "Subcommand [%s] is not valid, exiting.\n" "$1"
            exit 1
        }
    else
        printferr "Expected subcommand, exiting.\n"
        exit 1
    fi
}

parseargs() {
    [ -n "$1" ] || assertcmd

    while [ -n "$1" ]
    do
        if [ "${1%"${1#?}"}" = "-" ]
        then
            if [ "${1%"${1#??}"}" != "--" ]
            then
                sopt="$( printf "%s" "$1" | cut -c2- )"

                while [ -n "$sopt" ]
                do
                    opt="$( printf "%s" "$sopt" | cut -c1 )"

                    case "$opt"
                    in
                        h) printhelp; exit 0;;
                        l) loud="${loud}1";;
                        p) pperf="perf stat";;
                        q) quiet="${quiet}1";;
                        *) printusage "-$opt";;
                    esac

                    sopt="$( printf "%s" "$sopt" | cut -c2- )"
                done
            else
                opt="$( printf "%s" "$1" | cut -c3- )"
                
                case "$opt"
                in
                    help                 ) printhelp; exit 0;;
                    loud                 ) loud="${loud}1";;
                    print-performance    ) pperf="perf stat";;
                    no-print-performance ) pperf="";;
                    quiet                ) quiet="${quiet}1";;
                    *                    ) printusage "--$opt";;
                esac
            fi
        else
            break
        fi

        shift
    done

    cmd="$1"
    assertcmd "$cmd"
    shift

    case "$cmd"
    in
        concat)
            while [ -n "$1" ]
            do
                if [ "${1%"${1#?}"}" = "-" ]
                then
                    if ! [ "${1%"${1#??}"}" = "--" ]
                    then
                        sopt="$( printf "%s" "$1" | cut -c2- )"

                        while [ -n "$sopt" ]
                        do
                            opt="$( printf "%s" "$sopt" | cut -c1 )"

                            case "$opt"
                            in
                                F) shift; assertarg "-F" "COMMAND" "$1"; filter="$1";;
                                f) overwrite="-y";;
                                h) printhelp "concat"; exit 0;;
                                i) overwrite="";;
                                M) movefirst="1";;
                                m) shift; assertarg "-m" "MOVEFILE" "$1"; movefile="$1";;
                                n) overwrite="-n";;
                                r) remove="1";;
                                s) stdin="1";;
                                *) printusage "-$opt" "concat";;
                            esac

                            sopt="$( printf "%s" "$sopt" | cut -c2- )"
                        done
                    else
                        opt="$( printf "%s" "$1" | cut -c3- )"
                        
                        case "$opt"
                        in
                            filter        ) shift; assertarg "--filter" "COMMAND" "$1"; filter="$1";;
                            force         ) overwrite="-y";;
                            help          ) printhelp "concat"; exit 0;;
                            interactive   ) overwrite="";;
                            move-to       ) shift; assertarg "--move-to" "MOVEFILE" "$1"; movefile="$1";;
                            no-clobber    ) overwrite="-n";;
                            move-to-first ) movefirst="1";;
                            remove        ) remove="1";;
                            stdin         ) stdin="1";;
                            ""            ) shift; break;;
                            *             ) printusage "--$opt" "concat";;
                        esac
                    fi
                else
                    argv="$argv
$1"
                fi

                shift
            done

            for i
            do
                argv="$argv
$1"
            done

            argv="$( printf "%s" "$argv" | tail -n +2 )"

            infls="$( printf "%s" "$argv" | head -n -1 )"
            outfl="$( printf "%s" "$argv" | tail -n 1 )"

            [ "$( printf "%s\n" "$infls" | wc -l )" -lt 2 ] && {
                printferr "At least 2 in files and exactly one out file are required, exiting.\n"
                exit 1
            }

            printf "%s" "$infls" | grep -Fxq "$outfl" && {
                printferr "OUTFILE cannot be included in INFILES, exiting.\n"
                exit 1
            }

            ;;
        help)
            for i
            do
                if [ "$i" = "-h" ] || [ "$i" = "--help" ]
                then
                    printhelp "help"
                    exit 0
                else
                    printusage "$i" "help"
                fi
            done
            ;;
    esac
}

concat() {
    lstfl="$( mktemp -p . )"
    trap 'rm "$lstfl"' HUP INT QUIT TERM

    printf "%s\n" "$infls" | while IFS= read -r i
    do
        [ -f "$i" ] || {
            printferr "No such file [$i], exiting.\n"
            exit 1
        }

        printf "%s\n" "$i" >> "$lstfl"
    done

    [ -n "$filter" ] && {
        if [ -n "$stdin" ] 
        then
            $filter < "$lstfl" | sponge "$lstfl"
        else
            $filter "$lstfl" | sponge "$lstfl"
        fi
    }

    [ -n "$movefirst" ] && movefile="$( head -n 1 "$lstfl" )"

    awk '{print '"\"file '\""'$0'"\"'\""'}' "$lstfl" | sponge "$lstfl"

    $pperf ffmpeg -hide_banner $overwrite -f concat -safe 0 -i "$lstfl" -c copy "$outfl" || {
        printferr "ffmpeg failed, exiting.\n"
        [ -f "$lstfl" ] && rm "$lstfl"
        exit 1
    }

    [ -n "$remove" ] && printf "%s\n" "$infls" | while IFS= read -r i
    do
        rm "$i"
    done

    [ -n "$movefile" ] && {
        if [ "$overwrite" = "-y" ]
        then
            mv -f "$outfl" "$movefile"
        elif [ "$overwrite" = "-n" ]
        then
            mv -n "$outfl" "$movefile"
        else
            mv -i "$outfl" "$movefile"
        fi
    }

    [ -f "$lstfl" ] && rm "$lstfl"
}

main() {
    case "$cmd"
    in
        concat ) concat;;
        help   ) printhelp;;
    esac
}

parseargs "$@"

qldiff=$(( "${#quiet}" - "${#loud}" ))

if [ "$qldiff" -eq 1 ]
then
    main > /dev/null
elif [ "$qldiff" -gt 1 ]
then
    main > /dev/null 2>&1
else
    main
fi
