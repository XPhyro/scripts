#!/usr/bin/env sh
# Toggle an application on/off (i.e. launch or kill it).
# TODO: Add an option to force toggle applications, i.e. toggle on or toggle off. If they are already toggled on or off respectively, do nothing instead of toggling the state.
# TODO: Add the ability to toggle applications from a file, i.e. add the ability to read from a file toggleable things like getloc etc. and make the user select an application via dmenu, then toggle the selected application. This could be made into a more generic toggling system, using keycodes like in getloc etc. This way, key bindings in sxhkd will not be changed when an application used for a purpose changes (spt instead of spotify etc.).

printhelp() {
    printf "%s\n" \
    "scriptname [OPTION...] COMMAND -- COMMAND" \
    "   -h, --help" \
    "       Print help message." \
    "   -K, --auto-keycode" \
    "       Automatically assign a hash-like keycode to the given command. Overrides -k." \
    "   -k KEYCODE, --keycode KEYCODE" \
    "       Use KEYCODE to identify the given command. Overrides -K." \
    "   -t TIMEOUT, --timeout TIMEOUT" \
    "       When specified, wait TIMEOUT amount and SIGKILL the process if not terminated yet. The format is the same as in the sleep command."
}

printusage() {
    printf "Option [%s] is not valid.\n\n" "$1"
    printhelp
}

assertarg() {
    [ "$3" ] || {
        printf "Expected %s argument to %s, exiting.\n" "$2" "$1"
        exit 1
    }
}

parseargs() {
    while [ "$1" ]
    do
        if [ "${1%"${1#?}"}" = "-" ]
        then
            if ! [ "${1%"${1#??}"}" = "--" ]
            then
                sopt="$( printf "%s" "$1" | cut -c2- )"

                while [ "$sopt" ]
                do
                    opt="$( printf "%s" "$sopt" | cut -c1 )"

                    case "$opt"
                    in
                        K) autokeycode="1";;
                        k) shift; assertarg "-k" "KEYCODE" "$1"; keycode="$1"; autokeycode="0";;
                        t) shift; assertarg "-t" "TIMEOUT" "$1"; timeout="$1";;
                        h) printhelp; exit;;
                        *) printusage "-$opt"; exit;;
                    esac

                    sopt="$( printf "%s" "$sopt" | cut -c2- )"
                done
            else
                opt="$( printf "%s" "$1" | cut -c3- )"
                
                case "$opt"
                in
                    auto-keycode          ) autokeycode="1";;
                    keycode               ) shift; assertarg "--keycode" "KEYCODE" "$1"; keycode="$1"; autokeycode="0";;
                    timeout               ) shift; assertarg "--timeout" "TIMEOUT" "$1"; timeout="$1";;
                    help                  ) printhelp; exit;;
                    ""                    ) shift; break;;
                    *                     ) printusage "--$opt"; exit;;
                esac
            fi
        else
            cmd="$cmd \"$1\""
        fi

        shift
    done

    for i
    do
        cmd="$cmd \"$i\""
    done
}

logerr() {
    printf "[ERROR]: %s\n" "$@"
}

validateargs() {
    [ -z "$cmd" ] && logerr "Command cannot be empty."
}

setargs() {
    [ "$autokeycode" = "1" ] && keycode="$( printf "%s" "$cmd" | xxh128sum | awk '{print $1}' | tr -d '\n' )"
}

main() {
    flsdir="$( getloc --safe tglapp )" # Recommended to be a subdirectory of a directory mounted on volatile memory, such as /tmp/tglapp as /tmp is volatile on most systems.

    if ! [ -z "$keycode" ]
    then
        keyfl="$flsdir/$keycode"
        if [ -f $keyfl ]
        then
            pid="$( cat "$keyfl" )"
            if kill -s 0 "$pid"
            then
                kill "$pid" && {
                    rm -f "$keyfl"
                    [ -z "$timeout" ] || {
                        sleep "$timeout"
                        kill -s KILL "$pid"
                    }
                }
            else
                rm -f "$keyfl"
            fi
        else
            # TODO: Use exec instead of eval and log $$ instead of $!.
            eval "( $cmd ) &"
            printf "%s" "$!" > "$keyfl"
            wait
        fi
    else
        # TODO: Should grep, kill count, killall and other things that existed in the previous version of tglapp without keycodes be implemented here?
        eval "( $cmd )"
    fi
}

parseargs "$@"
validateargs
setargs
main
