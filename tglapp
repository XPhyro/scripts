#!/usr/bin/env sh
# Toggle an application on/off (i.e. launch or kill it).
# TODO: Add an option to force toggle applications, i.e. toggle on or toggle off. If they are already toggled on or off respectively, do nothing instead of toggling the state.
# TODO: Add the ability to toggle applications from a file, i.e. add the ability to read from a file toggleable things like getloc etc. and make the user select an application via dmenu, then toggle the selected application. This could be made into a more generic toggling system, using keycodes like in getloc etc. This way, key bindings in sxhkd will not be changed when an application used for a purpose changes (spt instead of spotify etc.).
# TODO: Add an option to replace the current instance of the application with the new instance. Allow the new instance to be different if -k is passed. If -k is not passed, but this new option is, just "restart" the application.

printhelp() {
    printf "%s\n" \
    "tglapp [OPTION...] COMMAND -- COMMAND" \
    "   -h, --help" \
    "       Print help message." \
    "   -k KEYCODE, --keycode KEYCODE" \
    "       Use KEYCODE to identify the given command instead of using a auto-computed hash." \
    "   -t TIMEOUT, --timeout TIMEOUT" \
    "       When specified, wait TIMEOUT amount and SIGKILL the process if not terminated yet. The TIMEOUT format is the same as in the sleep command."
}

printusage() {
    printf "Option [%s] is not valid.\n\n" "$1"
    printhelp
}

assertarg() {
    [ "$3" ] || {
        printf "Expected %s argument to %s, exiting.\n" "$2" "$1"
        exit 1
    }
}

parseargs() {
    while [ "$1" ]
    do
        if [ "${1%"${1#?}"}" = "-" ]
        then
            if ! [ "${1%"${1#??}"}" = "--" ]
            then
                sopt="$( printf "%s" "$1" | cut -c2- )"

                while [ "$sopt" ]
                do
                    opt="$( printf "%s" "$sopt" | cut -c1 )"

                    case "$opt"
                    in
                        k) shift; assertarg "-k" "KEYCODE" "$1"; keycode="$1";;
                        t) shift; assertarg "-t" "TIMEOUT" "$1"; timeout="$1";;
                        h) printhelp; exit;;
                        *) printusage "-$opt"; exit;;
                    esac

                    sopt="$( printf "%s" "$sopt" | cut -c2- )"
                done
            else
                opt="$( printf "%s" "$1" | cut -c3- )"
                
                case "$opt"
                in
                    keycode ) shift; assertarg "--keycode" "KEYCODE" "$1"; keycode="$1";;
                    timeout ) shift; assertarg "--timeout" "TIMEOUT" "$1"; timeout="$1";;
                    help    ) printhelp; exit;;
                    ""      ) shift; break;;
                    *       ) printusage "--$opt"; exit;;
                esac
            fi
        else
            cmd="$cmd \"$1\""
        fi

        shift
    done

    for i
    do
        cmd="$cmd \"$i\""
    done
}

logerr() {
    printf "[ERROR]: %s\n" "$@"
}

logerrq() {
    logerr "$@"
    exit 1
}

validateargs() {
    [ -z "$cmd" ] && logerrq "Command cannot be empty."
}

setargs() {
    [ -z "$keycode" ] && keycode="$( printf "%s" "$cmd" | xxh128sum | awk '{print $1}' | tr -d '\n' )"
}

main() {
    flsdir="$( getloc --safe tglapp )" # Recommended to be a subdirectory of a directory mounted on volatile memory, such as /tmp/tglapp as /tmp is volatile on most systems.

    keyfl="$flsdir/$keycode"
    if [ -f $keyfl ]
    then
        pid="$( cat "$keyfl" )"
        if kill -s 0 "$pid"
        then
            kill "$pid" && {
                rm -f "$keyfl"
                [ -z "$timeout" ] || {
                    sleep "$timeout"
                    kill -s KILL "$pid"
                }
            }
        else
            rm -f "$keyfl"
        fi
    else
        # TODO: Use exec instead of eval and log $$ instead of $!.
        eval "( $cmd ) &"
        printf "%s" "$!" > "$keyfl"
        wait
    fi
}

parseargs "$@"
validateargs
setargs
main
