#!/usr/bin/env sh
# Select a file or a directory using dmenu.
# TODO: Make -d respect -g.
# TODO: Add support for multiple -e.

printhelp() {
    printf "%s\n" \
        "selfl [OPTION...] [DIRECTORY...] -- [DIRECTORY...]" \
        "   -a, --absolute" \
        "       Print absolute path instead of relative." \
        "   -d, --directory" \
        "       Only show directories. If selecting a directory, you must exit without selecting after navigating to the wanted directory." \
        "   -E, --extended-regex" \
        "       Interpret PATTERNs as extended regular expressions. Overwrites -FGP." \
        "   -e PATTERN, --regex PATTERN" \
        "       Only show entries that are matched by the given regular expression. Only the last given pattern will be used." \
        "   -F, --fixed-strings" \
        "       Interpret PATTERNs as fixed strings. Overwrites -EGP." \
        "   -G, --basic-regex" \
        "       Interpret PATTERNs as basic regular expressions. This is the default interpretation. Overwrites -EFP." \
        "   -g, --git" \
        "       Use git ls-files to show files. Does nothing if -d is given." \
        "   -H, --with-directory" \
        "       Print initial directory with the selections." \
        "   -h, --help" \
        "       Print help message." \
        "   -i, --ignore-case" \
        "       Ignore case distinctions in PATTERNs and entries." \
        "   -P, --perl-regex" \
        "       Interpret PATTERNs as Perl-compatible regular expressions. Overwrites -EFG." \
        "   -R, --root-as-init" \
        "       Define the root as the initial directory." \
        "   -r ROOT, --root ROOT" \
        "       Define a custom root instead of /." \
        "   -s, --show-hidden" \
        "       Show hidden directories/files." \
        "   -v, --invert-match" \
        "       Only show entries that are not matched by PATTERNs."
}

printusage() {
    printf "Option [%s] is not valid.\n\n" "$1"
    printhelp
}

logerr() {
    printf "ERROR: %s\n" "$1"
}

cdsafe() {
    cd -- "$1" 2> /dev/null || {
        logerr "Could not cd to $1, exiting."
        exit 0
    }
}

assertarg() {
    [ "$3" ] || {
        printf "Expected %s argument to %s, exiting.\n" "$2" "$1"
        exit 1
    }
}

setdefargs(){
    root="/"
}

parseargs() {
    while [ "$1" ]
    do
        if [ "${1%"${1#?}"}" = "-" ]
        then
            if ! [ "${1%"${1#??}"}" = "--" ]
            then
                sopt="$( printf "%s" "$1" | cut -c2- )"

                while [ "$sopt" ]
                do
                    opt="$( printf "%s" "$sopt" | cut -c1 )"

                    case "$opt"
                    in
                        a) absolute="1";;
                        d) directory="1";;
                        E) regextype="-E";;
                        e) shift; assertarg "-e" "REGEX" "$1"; regex="$1";;
                        F) regextype="-F";;
                        G) regextype="-G";;
                        g) git="1";;
                        H) printinitpwd="1";;
                        h) printhelp; exit 0;;
                        i) ignorecase="-i";;
                        P) regextype="-P";;
                        r) shift; assertarg "-r" "ROOT" "$1"; root="$1"; rootasinit="0";;
                        R) rootasinit="1";;
                        s) showhidden="1";;
                        v) invertmatch="-v";;
                        *) printusage "-$opt"; exit 0;;
                    esac

                    sopt="$( printf "%s" "$sopt" | cut -c2- )"
                done
            else
                opt="$( printf "%s" "$1" | cut -c3- )"
                
                case "$opt"
                in
                    absolute       ) absolute="1";;
                    directory      ) directory="1";;
                    extended-regex ) regextype="-E";;
                    regex          ) shift; assertarg "-e" "REGEX" "$1"; regex="$1";;
                    fixed-strings  ) regextype="-F";;
                    basic-regex    ) regextype="-G";;
                    git            ) git="1";;
                    with-directory ) printinitpwd="1";;
                    help           ) printhelp; exit 0;;
                    ignore-case    ) ignorecase="-i";;
                    perl-regex     ) regextype="-P";;
                    root           ) shift; assertarg "-r" "ROOT" "$1"; root="$1"; rootasinit="0";;
                    root-as-init   ) rootasinit="1";;
                    show-hidden    ) showhidden="1";;
                    invert-match   ) invertmatch="-v";;
                    ""             ) shift; break;;
                    *              ) printusage "--$opt"; exit 0;;
                esac
            fi
        else
            initdirs="$initdirs$1
"
        fi

        shift
    done

    for i
    do
        initdirs="$initdirs$1
"
    done
}

grepfls() {
    [ "$regex" ] && {
        fls="$( printf "%s" "$fls" | grep $regextype $ignorecase $invertmatch -e "$regex" )"
    }
}

main() {
    if ! [ "$directory" ]
    then
        [ "$git" ] && initgithash="$( git rev-parse HEAD )"

        until [ -e "$sel" ] && [ ! -d "$sel" ]
        do
            [ -d "$sel" ] && cdsafe "$sel"

            if [ "$showhidden" ]
            then
                if [ "$git" ]
                then
                    [ "$( git rev-parse --is-inside-work-tree 2> /dev/null )" = "true" ] || {
                        logerr "Not a git repository, exiting."
                        return
                    }

                    fls="$( 
                        find . -mindepth 1 -maxdepth 1 -type d -printf "%P\n" | while read -r i
                        do 
                            cdsafe "$i"

                            if [ "$( git rev-parse --is-inside-work-tree 2> /dev/null )" = "true" ] && [ "$( git rev-parse HEAD )" = "$initgithash" ]
                            then
                                printf "%s\n" "$i"
                            fi

                            cdsafe ..
                        done | sort

                        git ls-files
                    )"
                else
                    fls="$( find . -mindepth 1 -maxdepth 1 -type d -printf "%P\n" | sort; find . -mindepth 1 -maxdepth 1 -type f -printf "%P\n" | sort )"
                fi
            else
                if [ "$git" ]
                then
                    [ "$( git rev-parse --is-inside-work-tree 2> /dev/null )" = "true" ] || {
                        logerr "Not a git repository, exiting."
                        return
                    }

                    fls="$( 
                        find . -mindepth 1 -maxdepth 1 -type d -not -name ".*" -printf "%P\n" | while read -r i
                        do 
                            cdsafe "$i"

                            if [ "$( git rev-parse --is-inside-work-tree 2> /dev/null )" = "true" ] && [ "$( git rev-parse HEAD )" = "$initgithash" ]
                            then
                                printf "%s\n" "$i"
                            fi

                            cdsafe ..
                        done | sort

                        git ls-files | sed -e '/^\..*/d' -e '/.*\/\..*/d'
                    )"
                else
                    fls="$( find . -mindepth 1 -maxdepth 1 -type d -not -name ".*" -printf "%P\n" | sort; find . -mindepth 1 -maxdepth 1 -type f -not -name ".*" -printf "%P\n" | sort )"
                fi
            fi

            grepfls

            if [ "$PWD" = "$root" ]
            then
                sel="$( printf "%s" "$fls"  | dmenu -i -p "$PWD" )"
            elif [ "$git" ]
            then
                if contains "$( realpath "$PWD/.." )" "$( git rev-parse --show-toplevel )"
                then
                    sel="$( printf "..\n%s" "$fls"  | dmenu -i -p "$PWD" )"
                else
                    sel="$( printf "%s" "$fls"  | dmenu -i -p "$PWD" )"
                fi
            else
                sel="$( printf "..\n%s" "$fls"  | dmenu -i -p "$PWD" )"
            fi

            printf "%s" "$fls" | grep -Fxq "$sel" || {
                [ "$sel" ] && sel="$( expandpath "$sel" )"
            }

            [ "$sel" ] || return
        done

        [ "$printinitpwd" ] && printinitpwd="$initpwd: "

        if [ "$absolute" ]
        then
            printf "%s%s\n" "$printinitpwd" "$PWD/$sel"
        else
            printf "%s%s\n" "$printinitpwd" "$( realpath --relative-to="$initpwd" "$PWD/$sel" )"
        fi
    else
        while true
        do
            [ -d "$sel" ] && cdsafe "$sel"

            if [ "$showhidden" ]
            then
                fls="$( find . -mindepth 1 -maxdepth 1 -type d -printf "%P\n" | sort )"
            else
                fls="$( find . -mindepth 1 -maxdepth 1 -type d -not -name ".*" -printf "%P\n" | sort )"
            fi

            grepfls

            if [ "$PWD" = "$root" ]
            then
                sel="$( printf "%s" "$fls"  | dmenu -i -p "$PWD" )"
            else
                sel="$( printf "..\n%s" "$fls"  | dmenu -i -p "$PWD" )"
            fi

            printf "%s" "$fls" | grep -Fxq "$sel" || sel="$( expandpath "$sel" )"

            [ "$sel" ] || {
                [ "$printinitpwd" ] && printinitpwd="$initpwd: "

                if [ "$absolute" ]
                then
                    printf "%s%s\n" "$printinitpwd" "$PWD"
                else
                    realpath --relative-to="$initpwd" "$PWD"
                fi

                return
            }
        done
    fi
}

setdefargs
parseargs "$@"

if [ "$initdirs" ]
then
    masterinitpwd="$PWD"
    printf "%s" "$initdirs" | while read -r i
    do
        cdsafe "$masterinitpwd"
        cdsafe "$i"

        initpwd="$PWD"
        [ "$rootasinit" = "1" ] && root="$initpwd"

        main
    done
else
    initpwd="$PWD"
    main
fi
