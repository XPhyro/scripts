#!/usr/bin/env sh
# Select a file or a directory using dmenu.
# TODO: Make -d respect -g.

printhelp() {
    printf "%s\n" "selfl [OPTION...] [DIRECTORY...]"
    printf "%s\n" "   -a, --absolute"
    printf "%s\n" "       Prints absolute path instead of relative."
    printf "%s\n" "   -d, --directory"
    printf "%s\n" "       Only shows directories. If selecting a directory, you must exit without selecting after navigating to the wanted directory."
    printf "%s\n" "   -g, --git"
    printf "%s\n" "       Use git ls-files to list files. Does nothing if -d is given."
    printf "%s\n" "   -H, --with-directory"
    printf "%s\n" "       Print initial directory with the selections."
    printf "%s\n" "   -h, --help"
    printf "%s\n" "       Print help message."
    printf "%s\n" "   -s, --show-hidden"
    printf "%s\n" "       Shows hidden directories/files."
}

printusage() {
    printf "Option [%s] is not valid.\n\n" "$1"
    printhelp
}

logerr() {
    printf "ERROR: %s\n" "$1"
}

cdsafe() {
    cd "$1" 2> /dev/null || {
        logerr "Could not cd to $1, exiting."
        exit
    }
}

parseargs() {
    while [ "$1" ]
    do
        if [ "${1%"${1#?}"}" = "-" ]
        then
            if ! [ "${1%"${1#??}"}" = "--" ]
            then
                sopt="$( printf "%s" "$1" | cut -c2- )"

                while [ "$sopt" ]
                do
                    opt="$( printf "%s" "$sopt" | cut -c1 )"

                    case "$opt" in
                        a) absolute="1";;
                        d) directory="1";;
                        g) git="1";;
                        h) printhelp; exit;;
                        H) printinitpwd="1";;
                        s) showhidden="1";;
                        *) printusage "-$opt"; exit;;
                    esac

                    sopt="$( printf "%s" "$sopt" | cut -c2- )"
                done
            else
                opt="$( printf "%s" "$1" | cut -c3- )"
                
                case "$opt" in
                    absolute       ) absolute="1";;
                    directory      ) directory="1";;
                    git            ) git="1";;
                    help           ) printhelp; exit;;
                    with-directory ) printinitpwd="1";;
                    show-hidden    ) showhidden="1";;
                    *              ) printusage "--$opt"; exit;;
                esac
            fi
        else
            initdirs="$initdirs$1
"
        fi

        shift
    done
}

main() {
    if ! [ "$directory" ]
    then
        [ "$git" ] && initgithash="$( git rev-parse HEAD )"

        until [ -e "$sel" ] && [ ! -d "$sel" ]
        do
            [ -d "$sel" ] && cdsafe "$sel"

            if [ "$showhidden" ]
            then
                if [ "$git" ]
                then
                    [ "$( git rev-parse --is-inside-work-tree 2> /dev/null )" = "true" ] || {
                        logerr "Not a git repository, exiting."
                        exit
                    }

                    fls="$( 
                        find . -mindepth 1 -maxdepth 1 -type d -printf "%P\n" | while read -r i
                        do 
                            cdsafe "$i"

                            if [ "$( git rev-parse --is-inside-work-tree 2> /dev/null )" = "true" ] && [ "$( git rev-parse HEAD )" = "$initgithash" ]
                            then
                                printf "%s\n" "$i"
                            fi

                            cdsafe ..
                        done | sort

                        git ls-files
                    )"
                else
                    fls="$( find . -mindepth 1 -maxdepth 1 -type d -printf "%P\n" | sort; find . -mindepth 1 -maxdepth 1 -type f -printf "%P\n" | sort )"
                fi
            else
                if [ "$git" ]
                then
                    [ "$( git rev-parse --is-inside-work-tree 2> /dev/null )" = "true" ] || {
                        logerr "Not a git repository, exiting."
                        exit
                    }

                    fls="$( 
                        find . -mindepth 1 -maxdepth 1 -type d -not -name ".*" -printf "%P\n" | while read -r i
                        do 
                            cdsafe "$i"

                            if [ "$( git rev-parse --is-inside-work-tree 2> /dev/null )" = "true" ] && [ "$( git rev-parse HEAD )" = "$initgithash" ]
                            then
                                printf "%s\n" "$i"
                            fi

                            cdsafe ..
                        done | sort

                        git ls-files | sed -e '/^\..*/d' -e '/.*\/\..*/d'
                    )"
                else
                    fls="$( find . -mindepth 1 -maxdepth 1 -type d -not -name ".*" -printf "%P\n" | sort; find . -mindepth 1 -maxdepth 1 -type f -not -name ".*" -printf "%P\n" | sort )"
                fi
            fi

            if [ "$PWD" = "/" ]
            then
                sel="$( printf "%s" "$fls"  | dmenu -i )"
            elif [ "$git" ]
            then
                if contains "$( realpath "$PWD/.." )" "$( git rev-parse --show-toplevel )"
                then
                    sel="$( printf "..\n%s" "$fls"  | dmenu -i )"
                else
                    sel="$( printf "%s" "$fls"  | dmenu -i )"
                fi
            else
                sel="$( printf "..\n%s" "$fls"  | dmenu -i )"
            fi

            printf "%s" "$fls" | grep -Fxq "$sel" || sel="$( expandpath "$sel" )"

            [ "$sel" ] || exit
        done

        [ "$printinitpwd" ] && printinitpwd="$initpwd: "

        if [ "$absolute" ]
        then
            printf "%s%s\n" "$printinitpwd" "$PWD/$sel"
        else
            printf "%s%s\n" "$printinitpwd" "$( realpath --relative-to="$initpwd" "$PWD/$sel" )"
        fi
    else

        while true
        do
            [ -d "$sel" ] && cdsafe "$sel"

            if [ "$showhidden" ]
            then
                fls="$( find . -mindepth 1 -maxdepth 1 -type d -printf "%P\n" | sort )"
            else
                fls="$( find . -mindepth 1 -maxdepth 1 -type d -not -name ".*" -printf "%P\n" | sort )"
            fi

            if [ "$PWD" = "/" ]
            then
                sel="$( printf "%s" "$fls"  | dmenu -i )"
            else
                sel="$( printf "..\n%s" "$fls"  | dmenu -i )"
            fi

            printf "%s" "$fls" | grep -Fxq "$sel" || sel="$( expandpath "$sel" )"

            [ "$sel" ] || {
                [ "$printinitpwd" ] && printinitpwd="$initpwd: "

                if [ "$absolute" ]
                then
                    printf "%s%s\n" "$printinitpwd" "$PWD"
                else
                    realpath --relative-to="$initpwd" "$PWD"
                fi

                break
            }
        done
    fi
}

parseargs "$@"

if [ "$initdirs" ]
then
    printf "%s" "$initdirs" | while read -r i
    do
        cdsafe "$i"

        initpwd="$PWD"
        main
    done
else
    initpwd="$PWD"
    main
fi
