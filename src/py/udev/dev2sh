#!/usr/bin/env python3


import argparse
import importlib.util
import multiprocessing as mp
import os
import subprocess as sp
import sys

import evdev as ev
from Xlib import display as xdisp


PROGRAM_NAME = "dev2sh"


class API:
    @staticmethod
    def spawn_cmd(cmd, *args, **kwargs):
        print(f"spawning command {cmd}")
        return sp.Popen(cmd, *args, **kwargs)

    @staticmethod
    def spawn_shell(cmd, *args, **kwargs):
        print(f"spawning shell {cmd}")
        return sp.Popen(cmd, *args, **kwargs, shell=True)

    @staticmethod
    def spawn(cmd, *args, **kwargs):
        cmd_type = type(cmd)

        if cmd_type in [list, tuple]:
            return API.spawn_cmd(cmd, *args, **kwargs)
        if cmd_type is str:
            return API.spawn_shell(cmd, *args, **kwargs)

        print(f"Could not determine how to spawn {repr(cmd)}.", file=sys.stderr)
        return None


class CallbackData:
    EVENT_TYPE_UP = 0
    EVENT_TYPE_DOWN = 1
    EVENT_TYPE_HOLD = 2
    EVENT_TYPE_NAMES = {0: "up", 1: "down", 2: "hold"}

    def __init__(self, button, event_type, value, sec, delta_sec):
        self.button = button
        self.event_type = event_type
        self.value = value
        self.sec = sec
        self.delta_sec = delta_sec

    def __str__(self):
        event_type_str = (
            self.event_type
            if self.button in [0, 1] or self.value != 1
            else self.EVENT_TYPE_NAMES.get(self.event_type, self.event_type)
        )
        return (
            f"{{button: {self.button}, event_type: {event_type_str}, "
            + f"value: {self.value}, sec: {self.sec:.4f}, "
            + f"delta_sec: {self.delta_sec:.4f}}}"
        )

    def __eq__(self, other):
        props = (self.button, self.event_type, self.value, self.sec, self.delta_sec)
        other_type = type(other)

        if other_type in [tuple, list]:
            if len(other) > 0 and type(other[0]) in [tuple, list]:
                for i in other:
                    if self != i:
                        return False
                return True
            for i in range(min(len(props), len(other))):
                if props[i] != other[i]:
                    return False
            return True

        if other_type is CallbackData:
            return props == (
                other.button,
                other.value,
                other.event_type,
                other.sec,
                other.delta_sec,
            )

        return self.button == other

    def __ne__(self, other):
        return not (self == other)


def parse_args():
    parser = argparse.ArgumentParser(
        prog=PROGRAM_NAME,
        description="Read input devices and execute shell commands accordingly.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument(
        "-c",
        "--config-path",
        default=(os.environ.get("XDG_CONFIG_HOME") or f"{os.environ['HOME']}/.config")
        + "/scripts/dev2sh/config.py",
        help="path to the configuration file",
    )

    parser.add_argument(
        "-l",
        "--list-devices",
        action="store_true",
        help="list device names for use in configuration files",
    )

    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="increase verbosity",
    )

    args = parser.parse_args()
    post_process_args(args)

    return args


def post_process_args(args):
    if args.list_devices:
        print(
            "\n".join(
                [
                    f"[{dev.name}]:\n\t{dev.capabilities(verbose=True)}"
                    for dev in [
                        ev.InputDevice(dev_path) for dev_path in ev.list_devices()
                    ]
                ]
            )
        )
        sys.exit(0)


def get_config(config_path):
    spec = importlib.util.spec_from_file_location(
        config_path.removesuffix(".py"), config_path
    )
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    module.API = API
    return module


def get_wm_props():
    display = xdisp.Display()
    root = display.screen().root
    net_wm_name = display.intern_atom("_NET_WM_NAME")
    net_active_window = display.intern_atom("_NET_ACTIVE_WINDOW")

    active_window_id = root.get_full_property(net_active_window, 0).value[0]

    window = display.create_resource_object("window", active_window_id)
    wm_name = window.get_full_property(net_wm_name, 0).value
    wm_class = window.get_wm_class()

    wm_instance = wm_class[0] if wm_class else None
    wm_class = wm_class[1] if wm_class else None
    wm_name = wm_name.decode("utf-8") if wm_name else None

    return (wm_class, wm_instance, wm_name)


def dev_read_loop(args, dev, selector_func):
    # TODO: spawn a thread (not a multiprocess) that monitors the focused window and updates callback_func with selector_func(...)
    callback_func = selector_func(*get_wm_props())

    with dev.grab_context():
        ui = ev.UInput.from_device(dev, name=f"{PROGRAM_NAME} {dev.name}")
        last_timestamps = {}
        i = 0
        for event in dev.read_loop():
            button, event_type, value = event.code, event.value, event.type
            if button == event_type == value == 0:
                continue

            last_timestamp = last_timestamps.get((button, value, event_type), (0, 0))

            sec = event.sec + event.usec / 1e6
            delta_sec = sec - (last_timestamp[0] + last_timestamp[1] / 1e6)
            callback_data = CallbackData(button, event_type, value, sec, delta_sec)

            if args.verbose:
                print(f"{i}: received event {callback_data}")

            if callback_func is not None:
                grab = callback_func(callback_data)

                if grab:
                    if not args.verbose:
                        print(f"{i}: received event {callback_data}")
                    print(f"caught event")
                else:
                    if args.verbose:
                        print(f"passed event through")
                    ui.write_event(event)
                    ui.syn()

            last_timestamps[(button, event_type, value)] = (event.sec, event.usec)

            i += 1


def main() -> int:
    args = parse_args()
    config = get_config(args.config_path)
    config_devs = config.dev_to_selector.keys()

    devs = []
    for dev in [ev.InputDevice(dev_path) for dev_path in ev.list_devices()]:
        if dev.name in config_devs:
            devs.append(dev)

    processes = []

    for dev in devs:
        process = mp.Process(
            target=dev_read_loop,
            args=(args, dev, config.dev_to_selector[dev.name]),
        )
        processes.append(process)
        process.start()

    for process in processes:
        process.join()

    return 0


if __name__ == "__main__":
    sys.exit(main())
