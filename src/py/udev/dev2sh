#!/usr/bin/env python3


import argparse
import importlib.util
import multiprocessing as mp
import os
import subprocess as sp
import sys
import threading as tp
import time

import evdev as ev
from Xlib import display as xdisp
import Xlib as xlib


PROGRAM_NAME = "dev2sh"


class API:
    print_buffer = []

    @staticmethod
    def spawn_cmd(cmd, *args, **kwargs):
        API.print_buffer.append((f"spawning command {repr(cmd)}", sys.stdout))
        return sp.Popen(cmd, *args, **kwargs)

    @staticmethod
    def spawn_shell(cmd, *args, **kwargs):
        API.print_buffer.append((f"spawning shell {repr(cmd)}", sys.stdout))
        return sp.Popen(cmd, *args, **kwargs, shell=True)

    @staticmethod
    def spawn(cmd, *args, **kwargs):
        cmd_type = type(cmd)

        if cmd_type in [list, tuple]:
            return API.spawn_cmd(cmd, *args, **kwargs)
        if cmd_type is str:
            return API.spawn_shell(cmd, *args, **kwargs)

        API.print_buffer.append(
            (f"could not determine how to spawn {repr(cmd)}", sys.stderr)
        )
        return None

    # TODO:
    # @staticmethod
    # def send_key_down():
    #     pass

    # TODO:
    # @staticmethod
    # def send_key_up():
    #     pass

    @staticmethod
    def type_text(text):
        API.spawn_cmd(["xdotool", "type", text])


class CallbackData:
    EVENT_TYPE_UP = 0
    EVENT_TYPE_DOWN = 1
    EVENT_TYPE_HOLD = 2
    EVENT_TYPE_NAMES = {0: "up", 1: "down", 2: "hold"}

    def __init__(self, button, event_type, value, sec, delta_sec):
        self.button = button
        self.event_type = event_type
        self.value = value
        self.sec = sec
        self.delta_sec = delta_sec

    def __str__(self):
        event_type_str = (
            self.event_type
            if self.button in [0, 1] or self.value != 1
            else self.EVENT_TYPE_NAMES.get(self.event_type, self.event_type)
        )
        return (
            f"{{button: {self.button}, event_type: {event_type_str}, "
            + f"value: {self.value}, sec: {self.sec:.4f}, "
            + f"delta_sec: {self.delta_sec:.4f}}}"
        )

    def __eq__(self, other):
        props = (self.button, self.event_type, self.value, self.sec, self.delta_sec)
        other_type = type(other)

        if other_type in [tuple, list]:
            if len(other) > 0 and type(other[0]) in [tuple, list]:
                for i in other:
                    if self != i:
                        return False
                return True
            for i in range(min(len(props), len(other))):
                if props[i] != other[i]:
                    return False
            return True

        if other_type is CallbackData:
            return props == (
                other.button,
                other.value,
                other.event_type,
                other.sec,
                other.delta_sec,
            )

        return self.button == other

    def __ne__(self, other):
        return not (self == other)


def parse_args():
    parser = argparse.ArgumentParser(
        prog=PROGRAM_NAME,
        description="Read input devices and execute shell commands accordingly.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument(
        "-c",
        "--config-path",
        default=(os.environ.get("XDG_CONFIG_HOME") or f"{os.environ['HOME']}/.config")
        + "/scripts/dev2sh/config.py",
        help="path to the configuration file",
    )

    parser.add_argument(
        "-l",
        "--list-devices",
        action="store_true",
        help="list device names for use in configuration files",
    )

    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="increase verbosity",
    )

    args = parser.parse_args()
    post_process_args(args)

    return args


def post_process_args(args):
    if args.list_devices:
        print(
            "\n".join(
                [
                    f"[{dev.name}]:\n\t{dev.capabilities(verbose=True)}"
                    for dev in [
                        ev.InputDevice(dev_path) for dev_path in ev.list_devices()
                    ]
                ]
            )
        )
        sys.exit(0)


def get_config(config_path):
    spec = importlib.util.spec_from_file_location(
        config_path.removesuffix(".py"), config_path
    )
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    module.API = API
    return module


def get_wm_props():
    try:
        display = xdisp.Display()
        root = display.screen().root
        net_wm_name = display.intern_atom("_NET_WM_NAME")
        net_active_window = display.intern_atom("_NET_ACTIVE_WINDOW")

        active_window_id = root.get_full_property(net_active_window, 0).value[0]

        window = display.create_resource_object("window", active_window_id)
        wm_name = window.get_full_property(net_wm_name, 0).value
        wm_class = window.get_wm_class()

        wm_instance = wm_class[0] if wm_class else ""
        wm_class = wm_class[1] if wm_class else ""
        wm_name = wm_name.decode("utf-8") if wm_name else ""
        return (wm_class, wm_instance, wm_name)
    except:
        return ("", "", "")


def update_selector_loop(selector_func):
    global callback_func

    display = xdisp.Display()
    root = display.screen().root
    net_active_window = display.intern_atom("_NET_ACTIVE_WINDOW")
    root.change_attributes(
        event_mask=xlib.X.PropertyChangeMask | xlib.X.SubstructureNotifyMask
    )

    while True:
        event = display.next_event()
        if event.type == xlib.X.PropertyNotify and event.atom == net_active_window:
            callback_func = selector_func(*get_wm_props())


def dev_read_loop_impl(args, dev_path, selector_funcs):
    dev = ev.InputDevice(dev_path)
    selector_func = selector_funcs[dev.name]

    global callback_func
    callback_func = selector_func(*get_wm_props())

    thread = tp.Thread(
        target=update_selector_loop,
        args=(selector_func,),
    )
    thread.start()

    with dev.grab_context():
        ui = ev.UInput.from_device(dev, name=f"{PROGRAM_NAME} {dev.name}")
        last_timestamps = {}
        i = 0
        for event in dev.read_loop():
            button, event_type, value = event.code, event.value, event.type
            if button == event_type == value == 0:
                continue

            last_timestamp = last_timestamps.get((button, value, event_type), (0, 0))

            sec = event.sec + event.usec / 1e6
            delta_sec = sec - (last_timestamp[0] + last_timestamp[1] / 1e6)
            callback_data = CallbackData(button, event_type, value, sec, delta_sec)

            if args.verbose:
                print(f"{i}: received event {callback_data}")

            if callback_func is not None:
                grab = callback_func(callback_data)

                if grab:
                    if API.print_buffer or args.verbose:
                        if not args.verbose:
                            print(f"{i}: received event {callback_data}")
                        print(f"caught event")
                else:
                    if args.verbose:
                        print(f"passed event through")
                    ui.write_event(event)
                    ui.syn()

                while API.print_buffer:
                    string, file = API.print_buffer.pop(0)
                    print(string, file=file)

            last_timestamps[(button, event_type, value)] = (event.sec, event.usec)

            i += 1


def dev_read_loop(args, dev_path, selector_funcs):
    while True:
        try:
            dev_read_loop_impl(args, dev_path, selector_funcs)
        except OSError as e:
            if e.errno != 19:
                raise e
        time.sleep(3.0)


def main() -> int:
    args = parse_args()
    config = get_config(args.config_path)

    processes = []
    for dev_path in ev.list_devices():
        process = mp.Process(
            target=dev_read_loop,
            args=(args, dev_path, config.dev_to_selector),
        )
        processes.append(process)
        process.start()

    for process in processes:
        process.join()

    return 0


if __name__ == "__main__":
    sys.exit(main())
